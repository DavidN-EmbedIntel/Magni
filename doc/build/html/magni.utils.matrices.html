<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>magni.utils.matrices module &#8212; Magni 1.7.0 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="magni.utils.plotting module" href="magni.utils.plotting.html" />
    <link rel="prev" title="magni.utils.config module" href="magni.utils.config.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="magni.utils.plotting.html" title="magni.utils.plotting module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="magni.utils.config.html" title="magni.utils.config module"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Magni 1.7.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="magni.html" >magni package</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="magni.utils.html" accesskey="U">magni.utils package</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-magni.utils.matrices">
<span id="magni-utils-matrices-module"></span><h1>magni.utils.matrices module<a class="headerlink" href="#module-magni.utils.matrices" title="Permalink to this headline">¶</a></h1>
<p>Module providing matrix emulators.</p>
<p>The matrix emulators of this module are wrappers of fast linear operations
giving the fast linear operations the same basic interface as a numpy ndarray.
Thereby allowing fast linear operations and numpy ndarrays to be used
interchangably in other parts of the package.</p>
<div class="section" id="routine-listings">
<h2>Routine listings<a class="headerlink" href="#routine-listings" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Matrix(magni.utils.validation.types.MatrixBase)</dt>
<dd>Wrap fast linear operations in a matrix emulator.</dd>
<dt>MatrixCollection(magni.utils.validation.types.MatrixBase)</dt>
<dd>Wrap multiple matrix emulators in a single matrix emulator.</dd>
<dt>Separable2DTransform(Matrix)</dt>
<dd>Wrap a linear 2D separable transform in a matrix emulator.</dd>
<dt>SRM(MatrixCollection)</dt>
<dd>Wrap a Structurally Random Matrix (SRM) in a matrix emulator.</dd>
<dt>SumApproximationMatrix(object)</dt>
<dd>Wrap a sum approximation in a matrix emulator.</dd>
<dt>norm(A, ord=None)</dt>
<dd>Compute a norm of a matrix.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-mod docutils literal"><span class="pre">magni.imaging._fastops</span></code></dt>
<dd>Fast linear operations.</dd>
<dt><code class="xref py py-mod docutils literal"><span class="pre">magni.imaging._mtx1D</span></code></dt>
<dd>1D transforms matrices for use 2D separable transforms.</dd>
</dl>
</div>
<dl class="class">
<dt id="magni.utils.matrices.Matrix">
<em class="property">class </em><code class="descclassname">magni.utils.matrices.</code><code class="descname">Matrix</code><span class="sig-paren">(</span><em>func</em>, <em>conj_trans</em>, <em>args</em>, <em>shape</em>, <em>is_complex=False</em>, <em>is_valid=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/magni/utils/matrices.html#Matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#magni.utils.matrices.Matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="magni.utils.validation.types.html#magni.utils.validation.types.MatrixBase" title="magni.utils.validation.types.MatrixBase"><code class="xref py py-class docutils literal"><span class="pre">magni.utils.validation.types.MatrixBase</span></code></a></p>
<p>Wrap fast linear operations in a matrix emulator.</p>
<p><a class="reference internal" href="#magni.utils.matrices.Matrix" title="magni.utils.matrices.Matrix"><code class="xref py py-obj docutils literal"><span class="pre">Matrix</span></code></a> defines a few attributes and internal methods which ensures that
instances have the same basic interface as a numpy ndarray instance without
explicitly forming the array. This basic interface allows instances to be
multiplied with vectors, to be transposed, to be complex conjuagted, and to
assume a shape. Also, instances have an attribute which explicitly forms
the matrix as an ndarray.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>func</strong> (<em>function</em>) &#8211; The fast linear operation applied to the vector when multiplying the
matrix with a vector.</li>
<li><strong>conj_trans</strong> (<em>function</em>) &#8211; The fast linear operation applied to the vector when multiplying the
complex conjuated transposed matrix with a vector.</li>
<li><strong>args</strong> (<em>list or tuple</em>) &#8211; The arguments which should be passed to <em class="xref py py-obj">func</em> and <em class="xref py py-obj">conj_trans</em> in
addition to the vector.</li>
<li><strong>shape</strong> (<em>list or tuple</em>) &#8211; The shape of the emulated matrix.</li>
<li><strong>is_complex</strong> (<em>bool</em>) &#8211; The indicator of whether or not the emulated matrix is defined for the
complex numbers (the default is False, which implies that the emulated
matrix is defined for the real numbers only).</li>
<li><strong>is_valid</strong> (<em>bool</em>) &#8211; The indicator of whether or not the fast linear operation corresponds
to a valid matrix (se discussion below) (the default is True, which
implies that the matrix is considered valid).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="magni.utils.validation.types.html#magni.utils.validation.types.MatrixBase" title="magni.utils.validation.types.MatrixBase"><code class="xref py py-class docutils literal"><span class="pre">magni.utils.validation.types.MatrixBase</span></code></a></dt>
<dd>Superclass of the present class.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The <em class="xref py py-obj">is_valid</em> indicator is an implementation detail used to control
possibly missing operations in the fast linear operation. For instance,
consider the Discrete Fourier Transform (DFT) and its inverse transform.
The forward DFT transform is a matrix-vector product involving the
corresponding DFT matrix. The inverse transform is a matrix-vetor product
involving the complex conjugate transpose DFT matrix. That is, it involves
complex conjugation and transposition, both of which are (individually)
valid transformations of the DFT matrix. However, when implementing the DFT
(and its inverse) using a Fast Fourier Transform (FFT), only the combined
(complex conjugate, transpose) operation is available. Thus, when using an
FFT based <em class="xref py py-obj">magni.util.matrices.Matrix</em>, one can get, e.g., a <a class="reference internal" href="#magni.utils.matrices.Matrix.T" title="magni.utils.matrices.Matrix.T"><code class="xref py py-obj docutils literal"><span class="pre">Matrix.T</span></code></a>
object corresponding to its transpose. However, the operation of computing
a matrix-vector product involving the tranpose DFT matrix is not available
and the <a class="reference internal" href="#magni.utils.matrices.Matrix.T" title="magni.utils.matrices.Matrix.T"><code class="xref py py-obj docutils literal"><span class="pre">Matrix.T</span></code></a> is, consequently, considered an invalid matrix. Only the
combined <em class="xref py py-obj">Matrix.T.conj()</em> or <em class="xref py py-obj">Matrix.conj().T</em> is considered a valid
matrix.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>The tranpose operation changed in <a class="reference internal" href="magni.html#module-magni" title="magni"><code class="xref py py-obj docutils literal"><span class="pre">magni</span></code></a> 1.5.0.</p>
<p class="last">For complex matrices, the the <a class="reference internal" href="#magni.utils.matrices.Matrix.T" title="magni.utils.matrices.Matrix.T"><code class="xref py py-obj docutils literal"><span class="pre">T</span></code></a> tranpose operation now yields an
invalid matrix as described above. Prior to <a class="reference internal" href="magni.html#module-magni" title="magni"><code class="xref py py-obj docutils literal"><span class="pre">magni</span></code></a> 1.5.0, the <a class="reference internal" href="#magni.utils.matrices.Matrix.T" title="magni.utils.matrices.Matrix.T"><code class="xref py py-obj docutils literal"><span class="pre">T</span></code></a>
would yield the &#8220;inverse&#8221; which would usually be the complex conjugated
transpose for complex matrices.</p>
</div>
<p class="rubric">Examples</p>
<p>For example, the negative identity matrix could be emulated as</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span><span class="o">,</span> <span class="nn">magni</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">magni.utils.matrices</span> <span class="k">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">vec</span><span class="p">:</span> <span class="o">-</span><span class="n">vec</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>The example matrix will have the desired shape:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 3)</span>
</pre></div>
</div>
<p>The example matrix will behave just like an explicit matrix:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
<span class="go">array([[-1.],</span>
<span class="go">       [-2.],</span>
<span class="go">       [-3.]])</span>
</pre></div>
</div>
<p>If, at some point, an explicit representation of the matrix is required,
this can easily be obtained:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span><span class="o">.</span><span class="n">A</span>
<span class="go">array([[-1., -0., -0.],</span>
<span class="go">       [-0., -1., -0.],</span>
<span class="go">       [-0., -0., -1.]])</span>
</pre></div>
</div>
<p>Likewise, the transpose of the matrix can be obtained:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">A</span>
<span class="go">array([[-1., -0., -0.],</span>
<span class="go">       [-0., -1., -0.],</span>
<span class="go">       [-0., -0., -1.]])</span>
</pre></div>
</div>
<dl class="method">
<dt id="magni.utils.matrices.Matrix.__array__">
<code class="descname">__array__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/magni/utils/matrices.html#Matrix.__array__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#magni.utils.matrices.Matrix.__array__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return ndarray representation of the matrix.</p>
</dd></dl>

<dl class="attribute">
<dt id="magni.utils.matrices.Matrix.matrix_state">
<code class="descname">matrix_state</code><a class="headerlink" href="#magni.utils.matrices.Matrix.matrix_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the internal matrix state.</p>
<p>The internal matrix state consists of:</p>
<ul class="simple">
<li>func: The forward fast linear operator.</li>
<li>conj_trans: The backward fast linear operator.</li>
<li>args: The tuple of extra arguments passed to <em class="xref py py-obj">func</em> and <em class="xref py py-obj">conj_trans</em>.</li>
<li>is_complex: The indicator of whether or not the matrix is complex.</li>
<li>is_valid: The indicator of whether or not the matrix is valid.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>matrix_state</strong> (<em>dict</em>) &#8211; A copy of the internal matrix state</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="magni.utils.matrices.Matrix.A">
<code class="descname">A</code><a class="headerlink" href="#magni.utils.matrices.Matrix.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Explicitly form the matrix.</p>
<p>The fast linear operations implicitly define a matrix which is usually
not explicitly formed. However, some functionality might require a more
advanced matrix interface than that provided by this class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>matrix</strong> (<em>numpy.ndarray</em>) &#8211; The explicit matrix.</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The explicit matrix is formed by multiplying the matrix with the
columns of an identity matrix and stacking the resulting vectors as
columns in a matrix.</p>
</dd></dl>

<dl class="attribute">
<dt id="magni.utils.matrices.Matrix.T">
<code class="descname">T</code><a class="headerlink" href="#magni.utils.matrices.Matrix.T" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the transpose of the matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>matrix</strong> (<em>Matrix</em>) &#8211; The transpose of the matrix.</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The fast linear operation and the fast linear transposed operation of
the resulting matrix are the same as those of the current matrix except
swapped. The shape is modified accordingly. This returns an <em class="xref py py-obj">invalid</em>
matrix if the entries are complex numbers as only the complex conjugate
transpose is considered valid.</p>
</dd></dl>

<dl class="method">
<dt id="magni.utils.matrices.Matrix.conj">
<code class="descname">conj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/magni/utils/matrices.html#Matrix.conj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#magni.utils.matrices.Matrix.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the complex conjugate of the matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>matrix</strong> (<em>Matrix</em>) &#8211; The complex conjugate of the matrix.</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The fast linear operation and the fast linear transposed operation of
the resulting matrix are the same as those of the current matrix.
This returns an <em class="xref py py-obj">invalid</em> matrix if the entries are complex numbers as
only the complex conjugate transpose is considered valid.</p>
</dd></dl>

<dl class="method">
<dt id="magni.utils.matrices.Matrix.dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>vec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/magni/utils/matrices.html#Matrix.dot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#magni.utils.matrices.Matrix.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply the matrix with a vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vec</strong> (<em>numpy.ndarray</em>) &#8211; The vector which the matrix is multiplied with.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>vec</strong> (<em>numpy.ndarray</em>) &#8211; The result of the multiplication.</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method honors <code class="xref py py-obj docutils literal"><span class="pre">magni.utils.validation.enable_validate_once</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="magni.utils.matrices.MatrixCollection">
<em class="property">class </em><code class="descclassname">magni.utils.matrices.</code><code class="descname">MatrixCollection</code><span class="sig-paren">(</span><em>matrices</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/magni/utils/matrices.html#MatrixCollection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#magni.utils.matrices.MatrixCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="magni.utils.validation.types.html#magni.utils.validation.types.MatrixBase" title="magni.utils.validation.types.MatrixBase"><code class="xref py py-class docutils literal"><span class="pre">magni.utils.validation.types.MatrixBase</span></code></a></p>
<p>Wrap multiple matrix emulators in a single matrix emulator.</p>
<p><a class="reference internal" href="#magni.utils.matrices.MatrixCollection" title="magni.utils.matrices.MatrixCollection"><code class="xref py py-obj docutils literal"><span class="pre">MatrixCollection</span></code></a> defines a few attributes and internal methods which
ensures that instances have the same basic interface as a numpy ndarray
instance without explicitly forming the ndarray. This basic interface
allows instances to be multiplied with vectors, to be transposed, to be
complex conjugated, and to assume a shape. Also, instances have an
attribute which explicitly forms the matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>matrices</strong> (<em>list or tuple</em>) &#8211; The collection of matrices (e.g. ndarrays or <a class="reference internal" href="#magni.utils.matrices.Matrix" title="magni.utils.matrices.Matrix"><code class="xref py py-obj docutils literal"><span class="pre">Matrix</span></code></a> instances).</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="magni.utils.validation.types.html#magni.utils.validation.types.MatrixBase" title="magni.utils.validation.types.MatrixBase"><code class="xref py py-class docutils literal"><span class="pre">magni.utils.validation.types.MatrixBase</span></code></a></dt>
<dd>Superclass of the present class.</dd>
<dt><a class="reference internal" href="#magni.utils.matrices.Matrix" title="magni.utils.matrices.Matrix"><code class="xref py py-class docutils literal"><span class="pre">Matrix</span></code></a></dt>
<dd>Matrix emulator.</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>For example, two matrix emulators can be combined into one. That is, the
matrix:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span><span class="o">,</span> <span class="nn">magni</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">vec</span><span class="p">:</span> <span class="o">-</span><span class="n">vec</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">negate</span> <span class="o">=</span> <span class="n">magni</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">matrices</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">negate</span><span class="o">.</span><span class="n">A</span>
<span class="go">array([[-1., -0., -0.],</span>
<span class="go">       [-0., -1., -0.],</span>
<span class="go">       [-0., -0., -1.]])</span>
</pre></div>
</div>
<p>And the matrix:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">vec</span><span class="p">:</span> <span class="n">vec</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reverse</span> <span class="o">=</span> <span class="n">magni</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">matrices</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reverse</span><span class="o">.</span><span class="n">A</span>
<span class="go">array([[ 0.,  0.,  1.],</span>
<span class="go">       [ 0.,  1.,  0.],</span>
<span class="go">       [ 1.,  0.,  0.]])</span>
</pre></div>
</div>
<p>Can be combined into one matrix emulator using the present class:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">magni.utils.matrices</span> <span class="k">import</span> <span class="n">MatrixCollection</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">MatrixCollection</span><span class="p">((</span><span class="n">negate</span><span class="p">,</span> <span class="n">reverse</span><span class="p">))</span>
</pre></div>
</div>
<p>The example matrix will have the desired shape:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 3)</span>
</pre></div>
</div>
<p>The example matrix will behave just like an explicit matrix:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
<span class="go">array([[-3.],</span>
<span class="go">       [-2.],</span>
<span class="go">       [-1.]])</span>
</pre></div>
</div>
<p>If, at some point, an explicit representation of the matrix is required,
this can easily be obtained:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span><span class="o">.</span><span class="n">A</span>
<span class="go">array([[-0., -0., -1.],</span>
<span class="go">       [-0., -1., -0.],</span>
<span class="go">       [-1., -0., -0.]])</span>
</pre></div>
</div>
<p>Likewise, the transpose of the matrix can be obtained:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">A</span>
<span class="go">array([[-0., -0., -1.],</span>
<span class="go">       [-0., -1., -0.],</span>
<span class="go">       [-1., -0., -0.]])</span>
</pre></div>
</div>
<dl class="method">
<dt id="magni.utils.matrices.MatrixCollection.__array__">
<code class="descname">__array__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/magni/utils/matrices.html#MatrixCollection.__array__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#magni.utils.matrices.MatrixCollection.__array__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return ndarray representation of the matrix.</p>
</dd></dl>

<dl class="attribute">
<dt id="magni.utils.matrices.MatrixCollection.matrix_state">
<code class="descname">matrix_state</code><a class="headerlink" href="#magni.utils.matrices.MatrixCollection.matrix_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the internal matrix state.</p>
<p>The internal matrix state consists of:</p>
<ul class="simple">
<li>matrices: The tuple of matrices in the matrix collection</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>matrix_state</strong> (<em>dict</em>) &#8211; A copy of the internal matrix state</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="magni.utils.matrices.MatrixCollection.A">
<code class="descname">A</code><a class="headerlink" href="#magni.utils.matrices.MatrixCollection.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Explicitly form the matrix.</p>
<p>The collection of matrices implicitly defines a matrix which is usually
not explicitly formed. However, some functionality might require a more
advanced matrix interface than that provided by this class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>matrix</strong> (<em>numpy.ndarray</em>) &#8211; The explicit matrix.</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The explicit matrix is formed by multiplying the matrix with the
columns of an identity matrix and stacking the resulting vectors as
columns in a matrix.</p>
</dd></dl>

<dl class="attribute">
<dt id="magni.utils.matrices.MatrixCollection.shape">
<code class="descname">shape</code><a class="headerlink" href="#magni.utils.matrices.MatrixCollection.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the shape of the matrix.</p>
<p>The shape of the product of a number of matrices is the number of rows
of the first matrix times the number of columns of the last matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>shape</strong> (<em>tuple</em>) &#8211; The shape of the matrix.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="magni.utils.matrices.MatrixCollection.T">
<code class="descname">T</code><a class="headerlink" href="#magni.utils.matrices.MatrixCollection.T" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the transpose of the matrix.</p>
<p>The transpose of the product of the number of matrices is the product
of the transpose of the matrices in reverse order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>matrix</strong> (<em>MatrixCollection</em>) &#8211; The transpose of the matrix.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="magni.utils.matrices.MatrixCollection.conj">
<code class="descname">conj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/magni/utils/matrices.html#MatrixCollection.conj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#magni.utils.matrices.MatrixCollection.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the complex conjugate of the matrix.</p>
<p>The complex conjugate of the product of the number of matrices is the
product of the complex conjugates of the matrices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>matrix</strong> (<em>MatrixCollection</em>) &#8211; The complex conjugate of the matrix.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="magni.utils.matrices.MatrixCollection.dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>vec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/magni/utils/matrices.html#MatrixCollection.dot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#magni.utils.matrices.MatrixCollection.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply the matrix with a vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vec</strong> (<em>numpy.ndarray</em>) &#8211; The vector which the matrix is multiplied with.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>vec</strong> (<em>numpy.ndarray</em>) &#8211; The result of the multiplication.</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method honors <code class="xref py py-obj docutils literal"><span class="pre">magni.utils.validation.enable_validate_once</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="magni.utils.matrices.Separable2DTransform">
<em class="property">class </em><code class="descclassname">magni.utils.matrices.</code><code class="descname">Separable2DTransform</code><span class="sig-paren">(</span><em>mtx_l</em>, <em>mtx_r</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/magni/utils/matrices.html#Separable2DTransform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#magni.utils.matrices.Separable2DTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#magni.utils.matrices.Matrix" title="magni.utils.matrices.Matrix"><code class="xref py py-class docutils literal"><span class="pre">magni.utils.matrices.Matrix</span></code></a></p>
<p>Wrap a linear 2D separable transform in a matrix emulator.</p>
<p>A linear 2D separable transform is defined by the two matrices <em class="xref py py-obj">mtx_l</em> and
<em class="xref py py-obj">mtx_r</em> in the sense that the Kronecker product kron(<em class="xref py py-obj">mtx_l</em>, <em class="xref py py-obj">mtx_r</em>)
yields the full matrix of the linear 2D separable transform when the linear
transform is implemented as a matrix-vector product. See e.g. <a class="footnote-reference" href="#id2" id="id1">[1]</a> for the
details.</p>
<p><a class="reference internal" href="#magni.utils.matrices.Separable2DTransform" title="magni.utils.matrices.Separable2DTransform"><code class="xref py py-obj docutils literal"><span class="pre">Separable2DTransform</span></code></a> defines a few attributes and internal methods which
ensures that instances have the same basic interface as a numpy matrix
instance without explicitly forming the matrix. This basic interface allows
instances to be multiplied with vectors, to be transposed, and to assume a
shape. Also, instances have an attribute which explicitly forms the matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mtx_l</strong> (<em>ndarray</em>) &#8211; The &#8220;left&#8221; matrix in the defining Kronecker product.</li>
<li><strong>mtx_r</strong> (<em>ndarray</em>) &#8211; The &#8220;right&#8221; matrix in the defining Kronecker product.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#magni.utils.matrices.Matrix" title="magni.utils.matrices.Matrix"><code class="xref py py-class docutils literal"><span class="pre">magni.utils.matrices.Matrix</span></code></a></dt>
<dd>Superclass of the present class.</dd>
</dl>
</div>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>A.N. Akansu, R.A. Haddad, and P.R. Haddad, <em>Multiresolution Signal
Decomposition: Transforms, Subbands, and Wavelets</em>, Academic Press,
2000.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>For example, the transform based on a 2-by-3 matrix and a 5-by-4 matrix</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">magni.imaging</span> <span class="k">import</span> <span class="n">vec2mat</span><span class="p">,</span> <span class="n">mat2vec</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">magni.utils.matrices</span> <span class="k">import</span> <span class="n">Separable2DTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mtx_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mtx_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">40</span><span class="p">)[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sep_matrix</span> <span class="o">=</span> <span class="n">Separable2DTransform</span><span class="p">(</span><span class="n">mtx_l</span><span class="p">,</span> <span class="n">mtx_r</span><span class="p">)</span>
</pre></div>
</div>
<p>The full transform matrix shape is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sep_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
<span class="go">(10, 12)</span>
</pre></div>
</div>
<p>The matrix behaves like an explicit matrix</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">36</span><span class="p">)[::</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sep_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
<span class="go">array([[  936],</span>
<span class="go">       [ 3528],</span>
<span class="go">       [ 2712],</span>
<span class="go">       [10056],</span>
<span class="go">       [ 4488],</span>
<span class="go">       [16584],</span>
<span class="go">       [ 6264],</span>
<span class="go">       [23112],</span>
<span class="go">       [ 8040],</span>
<span class="go">       [29640]])</span>
</pre></div>
</div>
<p>which, due to the separability of the transform, may also be computed as</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vec_as_mat</span> <span class="o">=</span> <span class="n">vec2mat</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mat2vec</span><span class="p">(</span><span class="n">mtx_l</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_as_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mtx_r</span><span class="o">.</span><span class="n">T</span><span class="p">)))</span>
<span class="go">array([[  936],</span>
<span class="go">       [ 3528],</span>
<span class="go">       [ 2712],</span>
<span class="go">       [10056],</span>
<span class="go">       [ 4488],</span>
<span class="go">       [16584],</span>
<span class="go">       [ 6264],</span>
<span class="go">       [23112],</span>
<span class="go">       [ 8040],</span>
<span class="go">       [29640]])</span>
</pre></div>
</div>
<p>The explicit matrix is given by the kronecker product of the two matrices</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">sep_matrix</span><span class="o">.</span><span class="n">A</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">mtx_l</span><span class="p">,</span> <span class="n">mtx_r</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The transpose of the matrix is also easily obtainable</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sep_matrix_transpose</span> <span class="o">=</span> <span class="n">sep_matrix</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sep_matrix_transpose</span><span class="o">.</span><span class="n">A</span>
<span class="go">array([[  0,   0,   0,   0,   0,   0,  24,  48,  72,  96],</span>
<span class="go">       [  0,   0,   0,   0,   0,   6,  30,  54,  78, 102],</span>
<span class="go">       [  0,   0,   0,   0,   0,  12,  36,  60,  84, 108],</span>
<span class="go">       [  0,   0,   0,   0,   0,  18,  42,  66,  90, 114],</span>
<span class="go">       [  0,   8,  16,  24,  32,   0,  32,  64,  96, 128],</span>
<span class="go">       [  2,  10,  18,  26,  34,   8,  40,  72, 104, 136],</span>
<span class="go">       [  4,  12,  20,  28,  36,  16,  48,  80, 112, 144],</span>
<span class="go">       [  6,  14,  22,  30,  38,  24,  56,  88, 120, 152],</span>
<span class="go">       [  0,  16,  32,  48,  64,   0,  40,  80, 120, 160],</span>
<span class="go">       [  4,  20,  36,  52,  68,  10,  50,  90, 130, 170],</span>
<span class="go">       [  8,  24,  40,  56,  72,  20,  60, 100, 140, 180],</span>
<span class="go">       [ 12,  28,  44,  60,  76,  30,  70, 110, 150, 190]])</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="magni.utils.matrices.Separable2DTransform.matrix_state">
<code class="descname">matrix_state</code><a class="headerlink" href="#magni.utils.matrices.Separable2DTransform.matrix_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the internal matrix state.</p>
<p>The internal matrix state consists of:</p>
<ul class="simple">
<li>mtx_l: The &#8220;left&#8221; matrix in the defining Kronecker product.</li>
<li>mtx_r: The &#8220;right&#8221; matrix in the defining Kronecker product.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>matrix_state</strong> (<em>dict</em>) &#8211; A copy of the internal matrix state</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="magni.utils.matrices.Separable2DTransform.A">
<code class="descname">A</code><a class="headerlink" href="#magni.utils.matrices.Separable2DTransform.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Explicitly form the matrix.</p>
<p>For a linear separable 2D transform, the full explicit transform matrix
is given by the Kronecker product of the two matrices that define the
separable transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>matrix</strong> (<em>ndarray</em>) &#8211; The explicit matrix.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="magni.utils.matrices.Separable2DTransform.T">
<code class="descname">T</code><a class="headerlink" href="#magni.utils.matrices.Separable2DTransform.T" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the transpose of the matrix.</p>
<p>The transpose of a Kronekcer product of two matrices is the Kronecker
product of the transposes of the two matrices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>matrix</strong> (<em>Separable2DTransform</em>) &#8211; The transpose of the matrix.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="magni.utils.matrices.Separable2DTransform.conj">
<code class="descname">conj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/magni/utils/matrices.html#Separable2DTransform.conj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#magni.utils.matrices.Separable2DTransform.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the complex conjugate of the matrix.</p>
<p>The complex conjugate of a Kronekcer product of two matrices is the
Kronecker product of the complex conjugates of the two matrices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>matrix</strong> (<em>Separable2DTransform</em>) &#8211; The complex conjugate of the matrix.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="magni.utils.matrices.Separable2DTransform.dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>vec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/magni/utils/matrices.html#Separable2DTransform.dot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#magni.utils.matrices.Separable2DTransform.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply the matrix with a vector.</p>
<p>The matrix-vector product is efficiently computed by
mtx_l.dot(V.dot(mtx_r.T)) where V is the matrix from which <em class="xref py py-obj">vec</em> was
created by stacking its columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vec</strong> (<em>ndarray</em>) &#8211; The vector corresponding to the stacked columns of a matrix which
this matrix is multiplied with.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>vec</strong> (<em>ndarray</em>) &#8211; The result of the matrix-vector multiplication.</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method honors <em class="xref py py-obj">magni.utils.validation.enable_allow_validate_once</em>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="magni.utils.matrices.SRM">
<em class="property">class </em><code class="descclassname">magni.utils.matrices.</code><code class="descname">SRM</code><span class="sig-paren">(</span><em>F</em>, <em>D=None</em>, <em>l_ran_arr=None</em>, <em>g_ran_arr=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/magni/utils/matrices.html#SRM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#magni.utils.matrices.SRM" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#magni.utils.matrices.MatrixCollection" title="magni.utils.matrices.MatrixCollection"><code class="xref py py-class docutils literal"><span class="pre">magni.utils.matrices.MatrixCollection</span></code></a></p>
<p>Wrap a Structurally Random Matrix (SRM) in a matrix emulator.</p>
<p>Structurally Random Matrices are detailed in [2]. They are composed of a
(row) sub-sampling matrix <em class="xref py py-obj">D</em>, an orthogonal matrix <em class="xref py py-obj">F</em>, and a
pre-randomization matrix <em class="xref py py-obj">R</em> such that the SRM (an m-by-n matrix) is given
by sqrt(n/m)*DFR with DFR being the matrix product of D, F, and R.</p>
<p>This class implements are sligthly more general SRM than the one just
described. Specifically, the scaling is absorbed into <em class="xref py py-obj">D</em> and may be
arbitrary, i.e. potentially different for each row. Furthermore, the <em class="xref py py-obj">F</em>
matrix is allowed to be an abitrary p-by-n matrix for <em class="xref py py-obj">D</em> an m-by-p matrix.
Finally, this class allows for either or both of local pre-randomization
(sign changes on columns) or global pre-randomization (permutation of
columns). If both local and global pre-randomization is used, the <em class="xref py py-obj">R</em>
matrix is composed as the matrix product <em class="xref py py-obj">R_gR_l</em> with <em class="xref py py-obj">R_g</em> the global
pre-randomization and <em class="xref py py-obj">R_l</em> the local.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>F</strong> (<em>ndarray or magni.utils.validation.types.MatrixBase</em>) &#8211; The p-by-n &#8220;base&#8221; matrix used in the SRM.</li>
<li><strong>D</strong> (<em>ndarray or magni.utils.validation.types.MatrixBase</em>) &#8211; The m-by-p sub-sampling matrix used in the SRM (the default is None,
which implies that no sub-sampling matrix is used in the SRM).</li>
<li><strong>l_ran_arr</strong> (<em>ndarray</em>) &#8211; The length n, ordered 1D array of signs to apply to the n columns (the
default is None, which implies that no signs are applied to the
columns).</li>
<li><strong>g_ran_arr</strong> (<em>ndarray</em>) &#8211; The length n, ordered 1D array of indices (zero-indexed) defining the
permutation of the n columns (the default is None, which implies that
the columns are not permuted) - see example below.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#magni.utils.matrices.MatrixCollection" title="magni.utils.matrices.MatrixCollection"><code class="xref py py-class docutils literal"><span class="pre">magni.utils.matrices.MatrixCollection</span></code></a></dt>
<dd>Superclass of the present class.</dd>
</dl>
</div>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>T.T. Do, L.. Gan, N.H. Nguyen, and T.D. Tran, &#8220;Fast and Efficient
Compressive Sensing Using Structurally Random Matrices&#8221;, <em>IEEE
Transactions on Signal Processing</em>, vol. 60, no. 1, pp. 139-154, 2012</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>For example, a sub-sampling of a 3-by-3 matrix</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">magni.utils.matrices</span> <span class="k">import</span> <span class="n">SRM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_1</span> <span class="o">=</span> <span class="n">SRM</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="n">D</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_1</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">real</span>
<span class="go">array([[ 3.,  4.,  5.],</span>
<span class="go">       [ 6.,  7.,  8.]])</span>
</pre></div>
</div>
<p>or a local pre-randomization (sign change)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">signs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_2</span> <span class="o">=</span> <span class="n">SRM</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">l_ran_arr</span><span class="o">=</span><span class="n">signs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_2</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">real</span>
<span class="go">array([[ 0., -1.,  2.],</span>
<span class="go">       [ 3., -4.,  5.],</span>
<span class="go">       [ 6., -7.,  8.]])</span>
</pre></div>
</div>
<p>or a global pre-randomization (permutation)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">permutation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_3</span> <span class="o">=</span> <span class="n">SRM</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">g_ran_arr</span><span class="o">=</span><span class="n">permutation</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_3</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">real</span>
<span class="go">array([[ 2.,  0.,  1.],</span>
<span class="go">       [ 5.,  3.,  4.],</span>
<span class="go">       [ 8.,  6.,  7.]])</span>
</pre></div>
</div>
<p>or everything together</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A_4</span> <span class="o">=</span> <span class="n">SRM</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="n">D</span><span class="p">,</span> <span class="n">l_ran_arr</span><span class="o">=</span><span class="n">signs</span><span class="p">,</span> <span class="n">g_ran_arr</span><span class="o">=</span><span class="n">permutation</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_4</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">real</span>
<span class="go">array([[ 5., -3.,  4.],</span>
<span class="go">       [ 8., -6.,  7.]])</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="magni.utils.matrices.SRM.matrix_state">
<code class="descname">matrix_state</code><a class="headerlink" href="#magni.utils.matrices.SRM.matrix_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the internal matrix state.</p>
<p>The internal matrix state consists of:</p>
<ul class="simple">
<li>matrices: The tuple of matrices in the SRM.</li>
<li>l_ran_arr: The local pre-randomization array.</li>
<li>g_ran_arr: The global pre-randomization array.</li>
<li>F_norm: The special F matrix used in norm computations.</li>
<li>includes: The dictionary detailing the SRM structure.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>matrix_state</strong> (<em>dict</em>) &#8211; A copy of the internal matrix state</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="magni.utils.matrices.SumApproximationMatrix">
<em class="property">class </em><code class="descclassname">magni.utils.matrices.</code><code class="descname">SumApproximationMatrix</code><span class="sig-paren">(</span><em>scaling</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/magni/utils/matrices.html#SumApproximationMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#magni.utils.matrices.SumApproximationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Wrap a sum approximation in a matrix emulator.</p>
<p>This simply emulates computing a scaled sum of the entries of a vector as a
matrix vector product.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>scaling</strong> (<em>int or float</em>) &#8211; The scaling applied to the sum approximation.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">magni.utils.matrices</span> <span class="k">import</span> <span class="n">SumApproximationMatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">6021</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np_printoptions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vec</span><span class="o">.</span><span class="n">mean</span><span class="p">()])</span>
<span class="go">array([ 0.43294])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">SumApproximationMatrix</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec</span><span class="p">)])</span>
<span class="go">array([ 0.43294])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="o">**</span><span class="n">np_printoptions</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="magni.utils.matrices.SumApproximationMatrix.dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>vec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/magni/utils/matrices.html#SumApproximationMatrix.dot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#magni.utils.matrices.SumApproximationMatrix.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Form the matrix-vector product sum approximation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vec</strong> (<em>ndarray</em>) &#8211; The vector in the matrix-vector product.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>scaled sum</strong> (<em>float</em>) &#8211; The scaled sum of the input vector.</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method honors <em class="xref py py-obj">magni.utils.validation.enable_allow_validate_once</em>.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="magni.utils.matrices.norm">
<code class="descclassname">magni.utils.matrices.</code><code class="descname">norm</code><span class="sig-paren">(</span><em>A</em>, <em>ord=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/magni/utils/matrices.html#norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#magni.utils.matrices.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a norm of a matrix.</p>
<p>Efficient norm computations for the <a class="reference internal" href="#module-magni.utils.matrices" title="magni.utils.matrices"><code class="xref py py-obj docutils literal"><span class="pre">magni.utils.matrices</span></code></a> matrices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>A</strong> (<em>magni.util.matrices.Matrix or magni.utils.matrices.MatrixCollection</em>) &#8211; The matrix which norm is to be computed.</li>
<li><strong>ord</strong> (<em>str</em>) &#8211; The order of the norm to compute.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>norm</strong> (<em>float</em>) &#8211; The computed matrix norm.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-func docutils literal"><span class="pre">numpy.linalg.norm()</span></code></dt>
<dd>Numpy&#8217;s function for computing norms of ndarrays</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function is a simple wrapper around <code class="xref py py-obj docutils literal"><span class="pre">numpy.linalg.norm</span></code>. It exploits
some properties of the matrix classes in <a class="reference internal" href="#module-magni.utils.matrices" title="magni.utils.matrices"><code class="xref py py-obj docutils literal"><span class="pre">magni.utils.matrices</span></code></a> to optimize
the norm computation in terms of speed and/or memory usage.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function builds the ndarray corresponding to the <em class="xref py py-obj">A</em> matrix and
passes that on to <code class="xref py py-obj docutils literal"><span class="pre">numpy.linalg.norm</span></code> if no smarter way of computing
the norm has been implemented. Beware of possible &#8220;out of memory&#8221;
issues.</p>
</div>
<p>Currently optimized norm computations are:</p>
<ul class="simple">
<li><a class="reference internal" href="#magni.utils.matrices.Separable2DTransform" title="magni.utils.matrices.Separable2DTransform"><code class="xref py py-obj docutils literal"><span class="pre">magni.utils.matrices.Separable2DTransform</span></code></a></li>
<li><a class="reference internal" href="#magni.utils.matrices.SRM" title="magni.utils.matrices.SRM"><code class="xref py py-obj docutils literal"><span class="pre">magni.utils.matrices.SRM</span></code></a> (particularly for <em class="xref py py-obj">F</em> a Separable2DTransform)</li>
</ul>
<p>If the <em class="xref py py-obj">A</em> matrix is a <em class="xref py py-obj">magni.util.matrices.SRM</em> and <em class="xref py py-obj">A.F_norm</em> is not
<em class="xref py py-obj">None</em>, the norm computation is accelerated using <em class="xref py py-obj">A.F_norm</em>. If the SRM
also includes sub-sampling, it is assumed that the <em class="xref py py-obj">F</em> matrix has entries
(or row norms) of the same size as is the case for an orthogonal matrix.
Furthermore, it is assumed that any sub-sampling does not include a
scaling, i.e. any scaling is not taken into account in computing the norm.
If these assumptions about the SRM are not fulfilled, the computed
Frobenius norm will only be an approximation to the true Frobernius norm.</p>
<p class="rubric">Examples</p>
<p>Compute the Frobenius norm of a Separable2DTransform</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">magni.utils.matrices</span> <span class="k">import</span> <span class="n">Separable2DTransform</span><span class="p">,</span> <span class="n">norm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mtx_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mtx_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">40</span><span class="p">)[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sep_matrix</span> <span class="o">=</span> <span class="n">Separable2DTransform</span><span class="p">(</span><span class="n">mtx_l</span><span class="p">,</span> <span class="n">mtx_r</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">sep_matrix</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">737.16</span>
</pre></div>
</div>
<p>for comparison, the Frobenius computed using np.linalg.norm is</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">sep_matrix</span><span class="o">.</span><span class="n">A</span><span class="p">)),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">737.16</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">magni.utils.matrices module</a><ul>
<li><a class="reference internal" href="#routine-listings">Routine listings</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="magni.utils.config.html"
                        title="previous chapter">magni.utils.config module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="magni.utils.plotting.html"
                        title="next chapter">magni.utils.plotting module</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="magni.utils.plotting.html" title="magni.utils.plotting module"
             >next</a> |</li>
        <li class="right" >
          <a href="magni.utils.config.html" title="magni.utils.config module"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Magni 1.7.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="magni.html" >magni package</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="magni.utils.html" >magni.utils package</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014-2017, Magni developers.
      Last updated on Mar 01, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>